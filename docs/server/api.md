# Lupo C2 API

The Lupo C2 server is designed to be "modular" in the sense that any implant can integrate into Lupo, no matter what language, framework, or runtime just by simply following a baseline API implementation.

So no matter what you want to write your Lupo C2 implants in, as long as it speaks HTTP(S)/TCP and supports the ability to construct/parse JSON then it will work flawlessly with Lupo.

## HTTP(S) API
When Lupo serves HTTP(S) connections it can parse data from either GET/POST requests based on the implementation preference of the implant developer. Both expect and handle the same parameters the exact same way, the primary difference is how they are sent based on the request.

- Available Parameters:
    - psk (REQUIRED - ALWAYS) = Pre-Shared key generated by the Lupo C2 server. Copy this key and bundle it with your implant for authentication to Lupo. 
    - sessionID (REQUIRED - AFTER REGISTRATION) = this value is returned to implants after successful registration and is simply a unique integer to tell the implant what session it is associated with.
    - UUID (REQUIRED - AFTER REGISTRATION) = this a secondary value that is returned to implants after successful registration. UUIDs server a special purpose as the core server primarily performs lookup operations with the sessionID. This is easier for iteration and processing, but sessionID can be easily brute forced if someone wants to flood the C2 server with bad session data. The UUID constraint helps restrict this as a sort of secondary PSK/unique identifier while allowing the core server to use the sessionID for everything else.
    - arch = the architecture of the implant's host OS system. By default this will be extracted from the UserAgent string if nothing is provided. This can be any string the implant wishes to provide, but is expected to be representative of OS/Architecture data.
    - update = an update interval in seconds. This should be the interval at which an implant will reach out to make requests. If not provided it will default to 0 server-side which means that Lupo will be unable to calculate the implant connection status if it dies. If provided the server will calculate the last check in on each update interval to determine if the implant is still active.
    - data = a data payload, usually any response that the implant wants to send back. This will be reflected to the operator of the server and requires no special format.
    - functions = any additional functions built into the implant that it wants to register in Lupo. If your implant implements a custom function you can tell Lupo about it via JSON by specifying {"name":"description"} in this parameter. You can include multiple key value pairs to register any number of custom functions. These will be displayed to the user of the server when interacting with a session and executing the "load" command.
    - register = boolean true/false. Defaults to false, but if passed in as true it will attempt to register a new session.

Below are some examples of the bare minimum parameters needed to get up and running. By default Lupo will always serve the next command in the command queue if the request is not a registration request. As such your basic implant loop should function as follows:

```
REGISTER_AGENT()
WHILE:
    IF OUTPUT_DATA:
        SEND_DATA(OUTPUT_DATA)

    CMD = GET_NEXT_CMD()

    IF CMD:
        PROCESS_CMD(CMD)
```

Once you've got an implant working, try using some of the other parameters to enhance the functionality!

### GET Requests

- Register a session:
    - Request:`https://myserver:1337/?psk=<psk>&register=true`
    - Response: `{"sessionID":"0","UUID":"00000000-0000-0000-0000-000000000000"}`
- Get next command:
    - Request: `https://myserver:1337/?psk=<psk>&sessionID=<ID>&UUID=<UUID>`
    - Response: `{"cmd":"<some_command>"}`
- Send output data:
    - Request: `https://myserver:1337/?psk=<psk>&sessionID=<ID>&UUID=<UUID>&data=<some_data>`
    - Response: `{"cmd":"<some_command>"}`
    - Data Output in Lupo: `lupo ☾ <some_data>` 

### POST Requests

- Register a session:
    - Request:`https://myserver:1337/
        - BODY: `psk=<psk>&register=true`
    - Response: `{"sessionID":"0","UUID":"00000000-0000-0000-0000-000000000000"}`
- Get next command:
    - Request: `https://myserver:1337/
        - BODY: `psk=<psk>&sessionID=<ID>&UUID=<UUID>`
    - Response: `{"cmd":"<some_command>"}`
- Send output data:
    - Request: `https://myserver:1337/
        - BODY: `psk=<psk>&sessionID=<ID>&UUID=<UUID>&data=<some_data>`
    - Response: `{"cmd":"<some_command>"}`
    - Data Output in Lupo: `lupo ☾ <some_data>` 


## TCP API
When Lupo serves TCP connections it expects the connecting implant to send all data in JSON to provide structure to the raw connection. This JSON structure is then mapped to expected parameters based on a TCPData structure. Outside of slight naming differences, all the parameters/responses are exactly the same and handled the exact same way as the HTTP(S) API making it easy to adapt implant connections to multiple protocols. NOTE: while the slight variation of names in the external interface does matter, capitalization does not. For example "PSK" will be accepted the same as "psk".

- Available Parameters:
    - psk (REQUIRED - ALWAYS) = Pre-Shared key generated by the Lupo C2 server. Copy this key and bundle it with your implant for authentication to Lupo. 
    - sessionID (REQUIRED - AFTER REGISTRATION) = this value is returned to implants after successful registration and is simply a unique integer to tell the implant what session it is associated with.
    - UUID (REQUIRED - AFTER REGISTRATION) = this a secondary value that is returned to implants after successful registration. UUIDs server a special purpose as the core server primarily performs lookup operations with the sessionID. This is easier for iteration and processing, but sessionID can be easily brute forced if someone wants to flood the C2 server with bad session data. The UUID constraint helps restrict this as a sort of secondary PSK/unique identifier while allowing the core server to use the sessionID for everything else.
    - ImplantArch = the architecture of the implant's host OS system. By default this will be extracted from the UserAgent string if nothing is provided. This can be any string the implant wishes to provide, but is expected to be representative of OS/Architecture data.
    - update = an update interval in seconds. This should be the interval at which an implant will reach out to make requests. If not provided it will default to 0 server-side which means that Lupo will be unable to calculate the implant connection status if it dies. If provided the server will calculate the last check in on each update interval to determine if the implant is still active.
    - data = a data payload, usually any response that the implant wants to send back. This will be reflected to the operator of the server and requires no special format.
    - AdditionalFunctions = any additional functions built into the implant that it wants to register in Lupo. If your implant implements a custom function you can tell Lupo about it via JSON by specifying {"name":"description"} in this parameter. You can include multiple key value pairs to register any number of custom functions. These will be displayed to the user of the server when interacting with a session and executing the "load" command.
    - register = boolean true/false. Defaults to false, but if passed in as true it will attempt to register a new session.

Below are some examples of the bare minimum parameters needed to get up and running. By default Lupo will always serve the next command in the command queue if the request is not a registration request. As such your basic implant loop should function as follows:

```
REGISTER_AGENT()
WHILE:
    IF OUTPUT_DATA:
        SEND_DATA(OUTPUT_DATA)

    CMD = GET_NEXT_CMD()

    IF CMD:
        PROCESS_CMD(CMD)
```

Once you've got an implant working, try using some of the other parameters to enhance the functionality!

### TCP Connection Examples
- Register a session:
    - Request:`connect to myserver 1337`
        - PAYLOAD: `{"psk":"<psk>","register":true}`
    - Response: `{"sessionID":"0","UUID":"00000000-0000-0000-0000-000000000000"}`
- Get next command:
    - Request:`connect to myserver 1337`
        - PAYLOAD: `{"psk":"<psk>","sessionID":<ID>,"UUID":"<UUID>"}`
    - Response: `{"cmd":"<some_command>"}`
- Send output data:
    - Request:`connect to myserver 1337`
        - PAYLOAD: `{"psk":"<psk>","sessionID":<ID>,"UUID":"<UUID>","data":"<some_data>"}`
    - Response: `{"cmd":"<some_command>"}`
    - Data Output in Lupo: `lupo ☾ <some_data>` 