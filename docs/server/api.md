# Lupo C2 API

The Lupo C2 server is designed to be "modular" in the sense that any implant can integrate into Lupo, no matter what language, framework, or runtime just by simply following a baseline API implementation.

So no matter what you want to write your Lupo C2 implants in, as long as it speaks HTTP(S)/TCP and supports the ability to construct/parse JSON then it will work flawlessly with Lupo.

## HTTP(S) API
When Lupo serves HTTP(S) connections it can parse data from either GET/POST requests based on the implementation preference of the implant developer. Both expect and handle the same parameters the exact same way, the primary difference is how they are sent based on the request.

- Available Parameters:
    - psk (REQUIRED - ALWAYS) = Pre-Shared key generated by the Lupo C2 server. Copy this key and bundle it with your implant for authentication to Lupo. 
    - sessionID (REQUIRED - AFTER REGISTRATION) = this value is returned to implants after successful registration and is simply a unique integer to tell the implant what session it is associated with.
    - UUID (REQUIRED - AFTER REGISTRATION) = this a secondary value that is returned to implants after successful registration. UUIDs server a special purpose as the core server primarily performs lookup operations with the sessionID. This is easier for iteration and processing, but sessionID can be easily brute forced if someone wants to flood the C2 server with bad session data. The UUID constraint helps restrict this as a sort of secondary PSK/unique identifier while allowing the core server to use the sessionID for everything else.
    - arch = the architecture of the implant's host OS system. By default this will be extracted from the UserAgent string if nothing is provided. This can be any string the implant wishes to provide, but is expected to be representative of OS/Architecture data.
    - update = an update interval in seconds. This should be the interval at which an implant will reach out to make requests. If not provided it will default to 0 server-side which means that Lupo will be unable to calculate the implant connection status if it dies. If provided the server will calculate the last check in on each update interval to determine if the implant is still active.
    - data = a data payload, usually any response that the implant wants to send back. This will be reflected to the operator of the server and requires no special format.
    - functions = any additional functions built into the implant that it wants to register in Lupo. If your implant implements a custom function you can tell Lupo about it via JSON by specifying {"name":"description"} in this parameter. You can include multiple key value pairs to register any number of custom functions. These will be displayed to the user of the server when interacting with a session and executing the "load" command.
    - register = boolean true/false. Defaults to false, but if passed in as true it will attempt to register a new session.
    - filename = a string value provided by an implant that is the filename for a file being sent to download or upload.
    - file = a string value that is expected to be a base64 encoded string that is a file to download or upload.

Below are some examples of the bare minimum parameters needed to get up and running. By default Lupo will always serve the next command in the command queue if the request is not a registration request. As such your basic implant loop should function as follows:

```
REGISTER_AGENT()
WHILE:
    IF OUTPUT_DATA:
        SEND_DATA(OUTPUT_DATA)
        
    IF NEW_UUID:
        REGISTER_AGENT() // Persistence option if -p flag is enabled in case server goes down (enabled by default)
        
    CMD = GET_NEXT_CMD()

    IF CMD:
        PROCESS_CMD(CMD)
```

Once you've got an implant working, try using some of the other parameters to enhance the functionality!

### GET Requests

- Register a session:
    - Request:`https://myserver:1337/?psk=<psk>&register=true`
    - Response: `{"sessionID":"0","UUID":"00000000-0000-0000-0000-000000000000"}`
- Get next command:
    - Request: `https://myserver:1337/?psk=<psk>&sessionID=<ID>&UUID=<UUID>`
    - Response: `{"cmd":"<some_command>"}`
- Send output data:
    - Request: `https://myserver:1337/?psk=<psk>&sessionID=<ID>&UUID=<UUID>&data=<some_data>`
    - Response: `{"cmd":"<some_command>"}`
    - Data Output in Lupo: `lupo ☾ <some_data>` 

### POST Requests

- Register a session:
    - Request:`https://myserver:1337/
        - BODY: `psk=<psk>&register=true`
    - Response: `{"sessionID":"0","UUID":"00000000-0000-0000-0000-000000000000"}`
- Get next command:
    - Request: `https://myserver:1337/
        - BODY: `psk=<psk>&sessionID=<ID>&UUID=<UUID>`
    - Response: `{"cmd":"<some_command>"}`
- Send output data:
    - Request: `https://myserver:1337/
        - BODY: `psk=<psk>&sessionID=<ID>&UUID=<UUID>&data=<some_data>`
    - Response: `{"cmd":"<some_command>"}`
    - Data Output in Lupo: `lupo ☾ <some_data>` 


## TCP API
When Lupo serves TCP connections it expects the connecting implant to send all data in JSON to provide structure to the raw connection. This JSON structure is then mapped to expected parameters based on a TCPData structure. Outside of slight naming differences, all the parameters/responses are exactly the same and handled the exact same way as the HTTP(S) API making it easy to adapt implant connections to multiple protocols. NOTE: while the slight variation of names in the external interface does matter, capitalization does not. For example "PSK" will be accepted the same as "psk".

- Available Parameters:
    - psk (REQUIRED - ALWAYS) = Pre-Shared key generated by the Lupo C2 server. Copy this key and bundle it with your implant for authentication to Lupo. 
    - sessionID (REQUIRED - AFTER REGISTRATION) = this value is returned to implants after successful registration and is simply a unique integer to tell the implant what session it is associated with.
    - UUID (REQUIRED - AFTER REGISTRATION) = this a secondary value that is returned to implants after successful registration. UUIDs server a special purpose as the core server primarily performs lookup operations with the sessionID. This is easier for iteration and processing, but sessionID can be easily brute forced if someone wants to flood the C2 server with bad session data. The UUID constraint helps restrict this as a sort of secondary PSK/unique identifier while allowing the core server to use the sessionID for everything else.
    - ImplantArch = the architecture of the implant's host OS system. By default this will be extracted from the UserAgent string if nothing is provided. This can be any string the implant wishes to provide, but is expected to be representative of OS/Architecture data.
    - update = an update interval in seconds. This should be the interval at which an implant will reach out to make requests. If not provided it will default to 0 server-side which means that Lupo will be unable to calculate the implant connection status if it dies. If provided the server will calculate the last check in on each update interval to determine if the implant is still active.
    - data = a data payload, usually any response that the implant wants to send back. This will be reflected to the operator of the server and requires no special format.
    - AdditionalFunctions = any additional functions built into the implant that it wants to register in Lupo. If your implant implements a custom function you can tell Lupo about it via JSON by specifying {"name":"description"} in this parameter. You can include multiple key value pairs to register any number of custom functions. These will be displayed to the user of the server when interacting with a session and executing the "load" command.
    - register = boolean true/false. Defaults to false, but if passed in as true it will attempt to register a new session.
    - filename = a string value provided by an implant that is the filename for a file being sent to download or upload.
    - file = a string value that is expected to be a base64 encoded string that is a file to download or upload.

Below are some examples of the bare minimum parameters needed to get up and running. By default Lupo will always serve the next command in the command queue if the request is not a registration request. As such your basic implant loop should function as follows:

```
REGISTER_AGENT()
WHILE:
    IF OUTPUT_DATA:
        SEND_DATA(OUTPUT_DATA)
        
    IF NEW_UUID:
        REGISTER_AGENT() // Persistence option if -p flag is enabled in case server goes down (enabled by default)
        
    CMD = GET_NEXT_CMD()

    IF CMD:
        PROCESS_CMD(CMD)
```

Once you've got an implant working, try using some of the other parameters to enhance the functionality!


# TCP Encryption
TCP Protcols support encryption via AES pre-shared keys. Unless you obfuscate your implant these keys are *NOT* inherently secure once your payload touches disk. It is always possible that they can be extracted to decrypt data offline in the event your implant is compromised. However, it does provide a base level of encryption in transit that will prevent transmitting clear text data a raw TCP socket.

To enable this use the `-e` flag when starting a TCP listener. All implants that connect to that listener are expected to send and receive raw hex data that is encrypted with the specified pre-shared key. This key must be embedded in your custom implant in order to work, but is *not* a new parameter that has to be sent. Simply configuring the listener, and embedding the relevant crypto functions in your implant is enough. A golang implementation that is used by the server is provided below, though it may be re-implemented in any language.

Sample TCP Cryptography Encrypt: 
```
        func encryptRoutineSample(){
                key := []byte(cryptoPSK)
                data := []byte(jsonResp)

                ciphertext, err := encrypt(data, key)
                if err != nil {
                    errorString := "Error encrypting TCP connection data for implant claiming to be session: " + strconv.Itoa(tcpParams.SessionID)
                    core.LogData(errorString)
                    core.ErrorColorBold.Println(errorString)
                    fmt.Println(err)
                }
                // Send Cipher Text Data PsuedoCode Example
                connection.Send(ciphertext)
        }

        func encrypt(plaintext []byte, key []byte) ([]byte, error) {
                c, err := aes.NewCipher(key)
                if err != nil {
                    return nil, err
                }

                gcm, err := cipher.NewGCM(c)
                if err != nil {
                    return nil, err
                }

                nonce := make([]byte, gcm.NonceSize())
                if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
                    return nil, err
                }

                return gcm.Seal(nonce, nonce, plaintext, nil), nil
            }

```

Sample TCP Cryptography Decrypt: 
```
        func decryptRoutineSample(){

            data := []byte(recvData)
            key := []byte(cryptoPSK)

            plaintext, err := decrypt(data, key)
            if err != nil {
                errorString := "Error decrypting TCP connection data from implant claiming to be session: " + strconv.Itoa(tcpParams.SessionID)
                core.LogData(errorString)
                core.ErrorColorBold.Println(errorString)
                fmt.Println(err)
            }
            recvData = string(plaintext)
            // Print the data or do something with it
            fmt.Println(recvData)
        }

        func decrypt(ciphertext []byte, key []byte) ([]byte, error) {
            c, err := aes.NewCipher(key)
            if err != nil {
                return nil, err
            }

            gcm, err := cipher.NewGCM(c)
            if err != nil {
                return nil, err
            }

            nonceSize := gcm.NonceSize()
            if len(ciphertext) < nonceSize {
                return nil, errors.New("ciphertext too short")
            }

            nonce, ciphertext := ciphertext[:nonceSize], ciphertext[nonceSize:]
            return gcm.Open(nil, nonce, ciphertext, nil)
        }


```

### TCP Connection Examples
- Register a session:
    - Request:`connect to myserver 1337`
        - PAYLOAD: `{"psk":"<psk>","register":true}`
    - Response: `{"sessionID":"0","UUID":"00000000-0000-0000-0000-000000000000"}`
- Get next command:
    - Request:`connect to myserver 1337`
        - PAYLOAD: `{"psk":"<psk>","sessionID":<ID>,"UUID":"<UUID>"}`
    - Response: `{"cmd":"<some_command>"}`
- Send output data:
    - Request:`connect to myserver 1337`
        - PAYLOAD: `{"psk":"<psk>","sessionID":<ID>,"UUID":"<UUID>","data":"<some_data>"}`
    - Response: `{"cmd":"<some_command>"}`
    - Data Output in Lupo: `lupo ☾ <some_data>` 

## Connector API
The Connector API is a "bind" API using HTTP/HTTPS. This means that these are parameters that your implant/web shell is expected to implement in order to integrate with the Lupo connector and establish a session.

- Available Parameters:
    - command query (REQUIRED - ALWAYS) = This is a primary command parameter. It can be GET/POST but must always be receivable by the target implant as all core commands are sent via this command regardless if they are extended functions or not just like how the HTTP/HTTPS and TCP servers post commands. In PHP a GET parameter example may look something like this `$_GET['cmd']` where the query ?cmd=(CMD) will be sent via the connector. This can be called anything but must be set correctly when starting a new connector. 
    - query parameters = connector shells don't technically implement the "extended functions" that the listeners do, instead these functions can be implemented by the target shell as optional parameters. to make use of these in your connector shell simply pass them in as HTTP based parameters. They must be pre-populated with data meaning the values are static. Additional functions can still technically be implemented via the command query at an implant's discretion but they cannot be loaded into the Lupo Session CLI interface as a reference requiring the user to follow along with a given implant's source/documentation.
    - filename = a string value provided by an implant that is the filename for a file being sent to download or upload.  
    - file = a string value that is expected to be a base64 encoded string that is a file to download or upload.

You can find a sample web shell in PHP that fully implements these functions in the `samples` section of the Lupo C2 repository. It should be noted that while proper HTTP responses are not _required_ by Lupo 2XX responses are used to measure whether or not a shell is active. As a result if you want somewhat accurate session status listings for connector based sessions your shell needs to return a 2XX response so Lupo knows it is alive. Not doing so will still allow you to interact with the session as long as it really exists, but will report an inaccurate status.
